#!/bin/bash
# a new start for configure3, for now just for c 

# Let gcc find all the dependencies and put them in $depfile

depfile=$(mktemp)
gcc -MM *.c > $depfile

# Process this with sed so that dependencies for each file are on 1 line.

depfileoneline=$(mktemp)
cat $depfile | sed -e 's/\\$/@@@/' -e 's/$/###/' | tr '\n' ' ' | sed -e 's/@@@### *//g' | sed -e 's/### /\n/g' > $depfileoneline

# This script will assume that if a file X.c depends on Y.h, there could be
# be a file called Y.c with the implementation.  When linking X.o one
# will therefore need Y.o as well.  The list of all Y.o will be in
# ${downobj[X.o]} (i.e., downobj is an associative bash array).
declare -A downobj
declare -A upobj

# read the lines of the $depfile
while read line; do
    # split the line into the objfile and the dependencies
    objfile=$(echo $line|awk -F: '{print $1}')
    addfile=$(echo $line|awk -F: '{print $2}')
    for f in $addfile; do
        # check that we're not creating a self-dependency
        if [[ "${f%.c}.o" != "$objfile" ]]; then
        if [[ "${f%.h}.o" != "$objfile" ]]; then
            addobjfile=${f%.h}.c
            # check that Y.c exists
            if [[ -f $addobjfile ]]; then 
                addobjfile=${f%.h}.o
                downobj[$objfile]="${downobj[$objfile]} $addobjfile"
                upobj[$addobjfile]="${upobj[$addobjfile]} $objfile"
            fi
        fi
        fi
    done
done < $depfileoneline

# detect main programs
mainfiles=$(grep -l main\( *.c)

if ! [[ "$mainfiles" == "" ]]; then

    # derive application names from source file names
    exenames=""
    for mainfile in $mainfiles; do
        exename=${mainfile%.c}
        exenames="$exenames $exename"
    done
    
    # start generating makefile

    # header
    echo "# makefile generated by buildconfig.sh for: "
    echo "#$exenames"
    echo -n '# on '
    date
    echo -n '# by '
    whoami
    echo
    echo "# 'all' target, builds all executables"
    echo
    echo -e "all: $exenames"
    echo
    echo "# source file dependencies"
    echo
    cat $depfileoneline
    echo
    echo "# linking commands for each executable"
    echo 
    for mainfile in $mainfiles; do
        # first rederive application name from source file name as above
        exename=${mainfile%.c}
        # this will need the current files object file in the least
        newobjects="${mainfile%.c}.o"
        objects=""
        # iteratively build object file list by adding "implied"
        # objects down the dependency graph
        while [[ "$newobjects" != "$objects" ]]; do
            # copy new to old
            objects=$newobjects
            # build new
            newobjects=""
            for o in $objects; do
                # add all implied objects in the old to the new one
                newobjects="$newobjects $o ${downobj[$o]}"
            done
            # normalize the list by sorting and keeping unique objects only
            newobjects=$(echo $newobjects|tr ' ' '\n'|sort|uniq|tr '\n' ' ')
        done
        # while we're doing this, keep a list of all objects (for 'clean')
        allobj="$allobj $newobjects"
        # write out the link command
        echo "$exename: $newobjects"
        echo -e '\t${CC} ${LDFLAGS} -o $@ $^ ${LDLIBS}\n'
    done
    # normalize the allobj list and use them for the clean command
    newallobj=$(echo $allobj| tr ' ' '\n' |sort|uniq|tr '\n' ' ')
    echo "# 'clean' command deletes the object files, which will "
    echo "# force a full rebuilt in the next 'make'"
    echo -e "\nclean:\n\trm -f ${newallobj}"
fi